#summary Explanation of how to write apps with RSTM

= Introduction =

RSTM supports two APIs.  The Library API is the legacy interface for RSTM.  On SPARC, it is currently the only supported interface.  On x86 with the Intel transactional C++ compiler, it is also possible to use the CXXTM API.  It is also possible to write code that works with both APIs.

== CXXTM API ==
If you are planning on using the Intel TM C++ compiler, you could just follow the rules in the draft C++ TM specification.  That is, you could:
  * wrap transactional regions with `__transaction[[atomic]] { ... }`
  * mark transactional functions as [[transaction_safe]]
  * mark regions that should not be instrumented with __transaction [[waiver]] { ... }
  * place the proper calls to initalize and shut down the STM library, and each thread's STM context.

By adding an include of <api/api.hpp>, you will also gain the following:
  * `STM_SET_POLICY(P)` to set the algorithm or adaptivity policy during execution.
  * `GET_ALGNAME()` to get the initial algorithm with which libstm was configured.

== Library API ==

The Library API allows maximum flexibility.  You can create new interfaces to libstm, and exploit them immediately.  However, it is also difficult.  With the library API, the programmer is responsible for making any shared memory access safe.  The programmer is also responsible for ensuring that allocation/reclamation are safe, and for adding API calls necessary for good performance.  

Consider the following example, which demonstrates manual instrumentation of shared memory loads and stores:

{{{ 
  atomic {
    x++;
  }
}}}

With the Library API, this becomes:
{{{
  BEGIN_TRANSACTION(atomic) {
    int z = _READ(x);
    _WRITE(x, z+1);
  } END_TRANSACTION;
}}}

Note that `BEGIN_TRANSACTION` should always be given the parameter `atomic`.

If your transaction calls `malloc` or `free`, you must use the transaction-safe variants: `TX_ALLOC` and `TX_FREE`.

Broadly speaking, you need to follow these additional rules:

  * Include <api/api.hpp> in your code.
  * Before any transactions, some thread must call `SYS_INIT`, and after all transactions are done, a thread must call `SYS_SHUTDOWN`.
  * A thread cannot perform transactions until it calls `THREAD_INIT`.  It should call `THREAD_SHUTDOWN` when it is done.
  * To forcibly change the current STM algorithm or adaptivity policy, use `STM_SET_POLICY(policyname)`, where policyname is either an algorithm name or an adaptive policy name.
  * To force a transaction to become irrevocable, use `BECOME_IRREVOC()`.

Furthermore, you should be careful about the following:

  * `_READ()` and `_WRITE()` require a valid transaction descriptor.  You can either ensure that a call to `GET_TXTHREAD()` occurs in a visible lexical scope, or else pass the descriptor to functions using the STAMP-inspired `TM_ARG` / `TM_ARG_ALONE` / `TM_PARAM` / `TM_PARAM_ALONE` interface.

  * Since self-abort does not quite follow the spec (it is not `cancel`), we expose `stm::restart()` for this purpose.

  * To find the algorithm name with which the system was initialized, use `GET_ALGNAME()`.  Note that this only returns the initial algorithm/policy configuration, not any changes due to adaptivity or explicit calls to `STM_SET_POLICY()`

There is a hack for fast nontransactional initialization of data structures, via `BEGIN_FAST_INITIALIZATION` and `END_FAST_INITIALIZATION`.  See the code for examples.

== Supporting Both APIs ==
If you program to the Library API, and then compile with the Intel C++ compiler, everything will _just work_ regardless of which API you use to configure and build.  There are a few caveats:

  * `TX_WAIVER`: If you know that a region should not be instrumented, then you need to place it in a "waiver" block.  To keep "waiver" compatible with the librar API, we use the macro `TX_WAIVER` instead of `__transaction [[waiver]]`.

  * Any function that is called from a transaction, and has shared memory accesses, must be marked [[transaction_safe]].  Using the `TX_CALLABLE` macro for this purpose ensures compatibility with the Library API.

  * You must make sure that code that requires irrevocability has a call to `BECOME_IRREVOC()`

== Hints ==
If you use the ProfileAppAll STM and run your code in single-thread mode, you can generate the total number of reads/writes per transaction.  This provides the start of a method for comparing library instrumentation to compiler instrumentation, and figuring out if something is being over-instrumented.